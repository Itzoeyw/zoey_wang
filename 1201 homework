"""reader.py — Read, modify, display, and save CSV / JSON / Pickle files."""

import sys
import os
import csv
import json
import pickle


# ──────────────────────────── Base Class ────────────────────────────

class FileHandler:
    """Base class for reading, modifying, displaying, and writing tabular data."""

    def __init__(self, filepath):
        self.filepath = filepath
        self.data = []          # list of lists (rows of strings)

    def read(self):
        raise NotImplementedError("Subclasses must implement read()")

    def write(self):
        raise NotImplementedError("Subclasses must implement write()")

    def display(self):
        """Print every row to the terminal."""
        for row in self.data:
            print(row)

    def modify(self, col, row, value):
        """Set data[row][col] = value, expanding the grid if necessary."""
        # add rows if needed
        while len(self.data) <= row:
            self.data.append([])
        # add columns in the target row if needed
        while len(self.data[row]) <= col:
            self.data[row].append("")
        self.data[row][col] = value


# ──────────────────────────── Subclasses ────────────────────────────

class CSVHandler(FileHandler):
    def read(self):
        with open(self.filepath, "r", newline="") as f:
            reader = csv.reader(f)
            self.data = [row for row in reader]

    def write(self):
        with open(self.filepath, "w", newline="") as f:
            writer = csv.writer(f)
            writer.writerows(self.data)


class JSONHandler(FileHandler):
    def read(self):
        with open(self.filepath, "r") as f:
            self.data = json.load(f)

    def write(self):
        with open(self.filepath, "w") as f:
            json.dump(self.data, f, indent=2)


class PickleHandler(FileHandler):
    def read(self):
        with open(self.filepath, "rb") as f:
            self.data = pickle.load(f)

    def write(self):
        with open(self.filepath, "wb") as f:
            pickle.dump(self.data, f)


# ──────────────────────────── Helpers ───────────────────────────────

def get_handler(filepath):
    """Return the correct handler subclass based on file extension."""
    ext = os.path.splitext(filepath)[1].lower()
    handlers = {
        ".csv":    CSVHandler,
        ".json":   JSONHandler,
        ".pickle": PickleHandler,
    }
    if ext not in handlers:
        print(f"Error: Unsupported file extension '{ext}'")
        sys.exit(1)
    return handlers[ext](filepath)


def parse_change(change_str):
    """Parse a change string 'X,Y,value' and return (col, row, value)."""
    parts = change_str.split(",")
    col   = int(parts[0].strip())
    row   = int(parts[1].strip())
    # value may itself contain commas, so rejoin the rest
    value = ",".join(parts[2:]).strip()
    return col, row, value


# ──────────────────────────── Main ──────────────────────────────────

def main():
    if len(sys.argv) < 3:
        print("Usage: python reader.py <source> <destination> [changes ...]")
        print('  Each change: "col,row,value"')
        sys.exit(1)

    src_path = sys.argv[1]
    dst_path = sys.argv[2]
    changes  = sys.argv[3:]

    # --- Validate source path ---
    if not os.path.exists(src_path) or not os.path.isfile(src_path):
        print(f"Error: '{src_path}' does not exist or is not a file.")
        directory = os.path.dirname(src_path) or "."
        print(f"Files in '{directory}':")
        for name in os.listdir(directory):
            full = os.path.join(directory, name)
            if os.path.isfile(full):
                print(f"  {name}")
        sys.exit(1)

    # --- Read source ---
    src_handler = get_handler(src_path)
    src_handler.read()

    # --- Apply changes ---
    for change in changes:
        col, row, value = parse_change(change)
        src_handler.modify(col, row, value)

    # --- Display modified data ---
    src_handler.display()

    # --- Write to destination ---
    dst_handler      = get_handler(dst_path)
    dst_handler.data = src_handler.data
    dst_handler.write()
    print(f"\nFile saved to '{dst_path}'")


if __name__ == "__main__":
    main()
